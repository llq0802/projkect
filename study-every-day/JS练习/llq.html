<!--
 * @Author: your name
 * @Date: 2021-10-15 09:08:23
 * @LastEditTime: 2021-10-15 17:52:26
 * @LastEditors: Please set LastEditors
 * @Description: In User Settings Edit
 * @FilePath: \vue3.0-cli-ts\study-every-day\JS练习\llq.html
-->
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <script src="">
      /*
            选择题 判断多选的情况
            */
      let arr1 = [
        {
          title: 'abcdefg',
          value: false,
        },
        {
          title: 'abcdef',
          value: true,
        },
        {
          title: 'abcd',
          value: true,
        },
        {
          title: 'abc',
          value: true,
        },
      ];
      let arr2 = [
        {
          title: 'abcdefg',
          value: true,
        },
        {
          title: 'abcdef',
          value: true,
        },

        {
          title: 'abcd',
          value: false,
        },
        {
          title: 'abc',
          value: false,
        },
      ];
      let ar = arr1.map((item) => item.value);
      let ar2 = arr2.map((item) => item.value);
      console.log(ar);
      console.log(ar2);
      let q = 0;
      let l = 0;
      let c = 0;
      function isTrue(ar, ar2) {
        let flag = false;
        for (i in ar) {
          if (ar[i] < ar2[i]) {
            flag = true;
            break;
          }
        }
        return flag;
      }
      let res111 = ar2.find((item, index) => {
        return item > ar[index];
      });
      let res11 = ar2.some((item, index) => {
        return ar.includes(item);
      });
      console.log(isTrue(ar, ar2));
      console.log(res111);
      console.log(res11);
      if (ar.toString() == ar2.toString()) {
        q++;
      } else if (res111) {
        c++;
      } else {
        l++;
      }
      // console.log('quandui--- ' + q, 'loule--- ' + l, 'cuoel--- ' + c);

      //*********************************//********************************//

      /*
                手写题！
              */

      // 1. Promise
      // let p = new Promise((resolve, reject) => {
      //   resolve(1)
      // })
      // p.then((i) => {},() => {})
      class Pro {
        constructor(executor) {
          this.status = 'pending';
          this.value = null;
          this.callbacks = [];
          function resolve(value) {
            if (this.status === 'pending') {
              this.value = value;
              this.status = 'resolve';
              setTimeout(() => {
                this.callbacks.forEach((item) => {
                  item.onResolve && item.onResolve(this.value);
                });
              });
            }
          }
          function reject(value) {
            if (this.status === 'pending') {
              this.value = value;
              this.status = 'reject';
              setTimeout(() => {
                this.callbacks.forEach((item) => {
                  item.onReject && item.onReject(this.value);
                });
              });
            }
          }
          executor(resolve.bind(this), reject.bind(this));
        }

        //then方法返回一个Promise
        then(onResolve, onRreject) {
          let callFn = (type) => {
            let result = type(this.value);
            // then手动返回的Promise不能与上一次相同
            if (thenPro == result) {
              throw new TypeError('Chaining cycle detected for promise');
            }
            try {
              if (result instanceof Pro) {
                // result.then(resolve,reject) //是下面的简写方式
                result.then(
                  (v) => {
                    resolve(v);
                  },
                  (r) => {
                    reject(r);
                  }
                );
              } else {
                resolve(result);
              }
            } catch (error) {
              reject(error);
            }
          };
          let thenPro = new Pro((resolve, reject) => {
            if (typeof resolve !== 'function') {
              resolve = (value) => value;
            }
            if (typeof reject !== 'function') {
              resolve = (value) => value;
            }
            if (this.status === 'resolve') {
              setTimeout(() => {
                callFn(onResolve);
              });
            }
            if (this.status === 'reject') {
              setTimeout(() => {
                callFn(onReject);
              });
            }
            if (this.status === 'pending') {
              this.callbacks.push({
                onResolve: () => {
                  callFn(onResolve);
                },
                onRreject: () => {
                  callFn(onRreject);
                },
              });
            }
          });
          return thenPro;
        }
        catch(onRreject) {
          return this.then(undefined, onRreject);
        }

        static resolve(value) {
          return new Pro((resolve, reject) => {
            try {
              if (value instanceof Pro) {
                value.then(
                  (v) => {
                    resolve(v);
                  },
                  (r) => {
                    reject(r);
                  }
                );
              } else {
                resolve(value);
              }
            } catch (error) {
              reject(error);
            }
          });
        }
        static reject(value) {
          return new Pro((resolve, reject) => {
            reject(value);
          });
        }

        static race(proArr) {
          return new Pro((resolve, reject) => {
            proArr.forEach((item, idnex) => {
              item.then(
                (v) => {
                  resolve(v);
                },
                (r) => {
                  reject(r);
                }
              );
            });
          });
        }

        static all(proArr) {
          let arr = [];
          return new Pro((resolve, reject) => {
            proArr.forEach((item, index) => {
              item.then(
                (v) => {
                  arr[index] = v;
                  if (arr.length === proArr.length) {
                    resolve(arr);
                  }
                },
                (r) => {
                  reject(r);
                }
              );
            });
          });
        }
      }
      //call
      Function.prototype.myCall = function(context, ...rest) {
        context.fn = this;
        let result = context.fn(...rest);
        delete context.fn;
        return result;
      };
      //apply
      Function.prototype.myApply = function(context, args) {
        context.fn = this;
        let res;
        if (!args) {
          res = context.fn();
        } else {
          res = context.fn(...args);
        }
        return res;
      };
      // 手写bind函数
      Function.prototype.myBind = function(context, ...args) {
        const thisFn = this; //当前调用的函数
        return function(...params) {
          thisFn.apply(context, [...args, ...params]);
        };
      };
      //new
      function myNew(fun, ...args) {
        let obj = {};
        obj.__proto__ = fun.prototype;
        let res = fun.apply(obj, args);
        return res instanceof Object ? res : obj;
      }

      function deepClone(obj) {
        // 先判断是对象还是数组
        let copy = obj instanceof Array ? [] : {};
        for (let key in obj) {
          // 判断是否是对象上的属性，而不是原型上的属性
          if (obj.hasOwnProperty(key)) {
            // obj[key] 是否是对象，如果是对象，递归遍历
            copy[key] = typeof obj[key] === 'object' ? deepClone(obj[key]) : obj[key];
          }
        }
        return copy;
      }
    </script>
  </body>
</html>

<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Document</title>
</head>

<body>
  <style lang="scss">
    /* scss练习*/

    /* @mixin important-text {
  color: red;
  font-size: 25px;
  font-weight: bold;
  border: 1px solid blue;
}
.content{
  @include important-text;
} */

    /* css3动画 */

    @keyframes myfirst {
      0% {
        background: red;
      }

      25% {
        background: yellow;
      }

      50% {
        background: blue;
      }

      100% {
        background: green;
      }
    }

    .container {
      /* animation: myfirst 5s linear 0s 1 alternate; */
      /* filter: blur(5px);模糊
       */
      /* filter: grayscale();灰度 */
      margin-left: 50%;
      margin-top: 100px;
      transform: translateX(-50%);
      display: flex;
      /* flex-direction: row;
      flex-wrap: wrap;
      justify-content: space-between;
      align-content: space-between;
      align-self: center; */
      overflow: hidden;
      /* 超出文字显示...*/
      text-overflow: ellipsis;
      white-space: nowrap;

      width: 400px;
      height: 400px;
      /* background-color: #eee; */
      background: linear-gradient(#e66465, #9198e5);
      transition: all 1s;
      box-sizing: border-box;
    }

    .container:hover {
      transform: scale(1.2, 1.2);
    }

    .item {
      flex: 1;
      height: 100px;
      border-radius: 50%;
      border: 1px solid white;
    }

    .test {
      width: 0;
      height: 0;
      border-left: 20px solid transparent;
      border-right: 20px solid transparent;
      border-top: 50px solid red;
    }
  </style>

  <div class="container">
    <div class="item"></div>
    <div class="item"></div>
    <div class="item"></div>
    <div class="item"></div>
  </div>

  <div class="test"></div>
  <script>
    class HD {
      constructor(executor) {
        this.state = 'pending';
        this.value = null;
        this.callbacks = [];
        function resolve(value) {
          if (this.state === 'pending') {
            this.state === 'resolve';
            this.value = value;
            setTimeout(() => {
              this.callbacks.map((item) => {
                item.onResove && item.onResove();
              });
            });
          }
        }
        function reject(value) {
          if (this.state === 'pending') {
            this.state === 'reject';
            this.value = value;
            setTimeout(() => {
              this.callbacks.map((item) => {
                item.onReject && item.onReject();
              });
            });
          }
        }
        try {
          executor(resolve.bind(this), reject.bind(this));
        } catch (error) {
          reject(error);
        }
      }

      then(onResove, onReject) {
        if (onResove != 'function') {
          onResove = (value) => value;
        }
        if (onReject != 'function') {
          onReject = (value) => value;
        }
        function callFn(typeFn) {
          let result = typeFn(this.value);
          if (thenResult === result) throw new TypeError('Chaining cycle detected for promise');
          try {
            if (result instanceof HD) {
              result.then(
                (r) => {
                  resolve(r);
                },
                (v) => {
                  reject(v);
                }
              );
            } else {
              resolve(result);
            }
          } catch (error) {
            reject(error);
          }
        }
        let thenResult = new Hd((resolve, reject) => {
          if (this.state === 'resolve') {
            setTimeout(() => {
              callFn(onResove);
            });
          }
          if (this.state === 'reject') {
            setTimeout(() => {
              callFn(onReject);
            });
          }
          if (this.state === 'pending') {
            this.callbacks.push({
              onResove: () => {
                callFn(onResove);
              },
              onReject: () => {
                callFn(onReject);
              },
            });
          }
        });

        return thenResult;
      }

      catch(onReject) {
        return this.then(undefined, onReject);
      }

      static resolve(value) {
        return new Hd((resolve, reject) => {
          try {
            if (value instanceof Hd) {
              value.then(resolve, reject);
            } else {
              resolve(value);
            }
          } catch (error) {
            reject(error);
          }
        });
      }
      static reject(value) {
        return new Hd((resolve, reject) => {
          reject(value);
        });
      }

      static race(proArrs) {
        return new Hd((resolve, reject) => {
          proArrs.forEach((proArr) => {
            proArr.then(resolve, reject);
          });
        });
      }
      static all(proArrs) {
        let arrayResult = [];
        return new Hd((resolve, reject) => {
          proArrs.forEach((item, index) => {
            item.then(
              (r) => {
                arrayResult[index] = r;
                if (arrayResult.length === proArrs.length) {
                  resolve(arrayResult);
                }
              },
              (v) => {
                reject(v);
              }
            );
          });
        });
      }
    }

      // 做用slice函数做分页分割时，或者数组分割时 前一个永远比后一个参数page少1  slice(index*size,(index+1)*size)
      // 前端分页 slice((page-1)*size,page*size)
      // 条件1 ? 表达式1 : 条件2 ? 表达式2 : 条件3 ? 表达式3 : 表达式4
      //随机生成字符串＋数字Math.random().toString(36).slice(2)

      //  == 进行比较时，如果两边数据类型不一样，先转化成相同护具类型。规则如下：
      // 1.{} =={}  两个对象（obj，fun，arr，date，reg）比较时，比较的是堆内存的地址
      // 2. null == undefined成立/ null===undefined不成立
      // 3. NaN==NaN不成立 NaN和谁都不相等
      // 4.对象与字符串比较时，调用对象原型的toString()方法转成字符串在进行比较
      //5.  剩余情况比较时，都是转成数字进行比较（前提是数据类型不一样）

      // 页面（window）滚动条到底部的条件即为：scrollTop + clientHeight == scrollHeight

      // 观察某个元素el 是否在屏幕可视区范围
      // const ob = new  IntersectionObserver((e)=>{
      //   e.isIntersecting  是否在可视区内
      // })
      //建立观察ob.observe(el)
      //取消观察ob ob.unobserve(el)

      // 动画定时器 间隔时间为屏幕刷新帧数 用法与setTimeout一样
      // requestAnimationFrame(() => {});渲染函数
      // cancelAnimationFrame();

      // el.getBoundingClientRect() 返回元素距离视口的空间位置对象

      // 通过FileReader.readAsDataURL(file)可以获取一段data:base64的字符串
      // 通过URL.createObjectURL(blob)可以获取当前文件的一个内存URL

      // ['1','2','3'].map(parseInt) =>[1,NaN,NaN]
      // parseInt() 接受两个参数，第二个是标识是什么进制的数，必须在（2-36）之间， 0表示10进制 2表示2进制 1会返回NaN

      // 0.1+0.2=0.3000000000004 他们转化成二进制是无限循环！ IEEE754标准 64位双精度表示（符号位 0正数 1负数，指数位，有效位，）

      // 浏览器
      //  1先主代码
      //  2微任务
      //  3宏任务
      // 注意：每次执行完一个宏任务 就会立刻去查找执行微任务
      // node事件
      //  1先主代码
      // 2.  process.next()
      //3.    Promise     2 3 都是微任务
      // timer 模块0ms
      // i/o I/O 回调。
      // check模块    setimmediate()
      //close callbacks

      // 执行上下文创建阶段：作用域链、变量对象、this
      // 执行上下文执行阶段：变量赋值、函数引用

      //console.log(self); // self不管在哪儿始终指向window

      // 分片 端点 上传大文件思路
      // 前端用file.slice()分块
      // 前端用FileReader获取每一分块的md5值 （spark-MD5插件）
      // 前端上传每一分块前，都会去服务器校验分片是否已上传，以此来支持断点续传
      // 后端用MultipartFile接受分块文件
      // 后端用FileOutputStream拼装分块文件
      // 500M以下的用http协议传输(网上一搜大把的)
      // 500M以上1G以下的用http协议分块或者ftp协议传输
      // 1G以上的只能用ftp协议传输
  </script>
</body>

</html>
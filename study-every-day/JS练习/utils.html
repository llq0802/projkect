<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>

  <body>
    <style lang="scss">
      /* scss练习*/

      /* @mixin important-text {
  color: red;
  font-size: 25px;
  font-weight: bold;
  border: 1px solid blue;
}
.content{
  @include important-text;
} */

      /* css3动画 */

      @keyframes myfirst {
        0% {
          background: red;
        }

        25% {
          background: yellow;
        }

        50% {
          background: blue;
        }

        100% {
          background: green;
        }
      }

      .container {
        /* animation: myfirst 5s linear 0s 1 alternate; */
        /* filter: blur(5px);模糊
       */
        /* filter: grayscale();灰度 */
        margin-left: 50%;
        margin-top: 100px;
        transform: translateX(-50%);
        display: flex;
        /* flex-direction: row;
      flex-wrap: wrap;
      justify-content: space-between;
      align-content: space-between;
      align-self: center; */
        overflow: hidden;
        /* 超出文字显示...*/
        text-overflow: ellipsis;
        white-space: nowrap;

        width: 400px;
        height: 400px;
        /* background-color: #eee; */
        background: linear-gradient(#e66465, #9198e5);
        transition: all 1s;
        box-sizing: border-box;
      }

      .container:hover {
        transform: scale(1.2, 1.2);
      }

      .item {
        flex: 1;
        height: 100px;
        border-radius: 50%;
        border: 1px solid white;
      }

      .test {
        width: 0;
        height: 0;
        border-left: 20px solid transparent;
        border-right: 20px solid transparent;
        border-top: 50px solid red;
      }
    </style>

    <div class="container">
      <div class="item"></div>
      <div class="item"></div>
      <div class="item"></div>
      <div class="item"></div>
    </div>

    <div class="test"></div>
    <script>
      class HD {
        constructor(executor) {
          this.state = 'pending';
          this.value = null;
          this.callbacks = [];
          function resolve(value) {
            if (this.state === 'pending') {
              this.state === 'resolve';
              this.value = value;
              this.callbacks.map((item) => {
                item.onResove && item.onResove();
              });
            }
          }
          function reject(value) {
            if (this.state === 'pending') {
              this.state === 'reject';
              this.value = value;
              this.callbacks.map((item) => {
                item.onReject && item.onReject();
              });
            }
          }
          try {
            executor(resolve.bind(this), reject.bind(this));
          } catch (error) {
            reject(error);
          }
        }

        then(onResove, onReject) {
          if (onResove != 'function') {
            onResove = (value) => value;
          }
          if (onReject != 'function') {
            onReject = (value) => value;
          }

          let thenResult = new Hd((resolve, reject) => {
            if (this.state === 'resolve') {
              let result = onResove(this.value);
              try {
                if (result instanceof HD) {
                  result.then(
                    (r) => {
                      resolve(r);
                    },
                    (v) => {
                      reject(v);
                    }
                  );
                } else {
                  resolve(result);
                }
              } catch (error) {
                reject(error);
              }
            }
            if (this.state === 'reject') {
              let result = onReject(this.value);
              try {
                if (result instanceof HD) {
                  result.then(
                    (r) => {
                      resolve(r);
                    },
                    (v) => {
                      reject(v);
                    }
                  );
                } else {
                  resolve(thenresultResult);
                }
              } catch (error) {
                reject(error);
              }
            }
            if (this.state === 'pending') {
              this.callbacks.push({
                onResove: () => {
                  let result = onResove(this.value);
                  try {
                    if (result instanceof HD) {
                      result.then(
                        (r) => {
                          resolve(r);
                        },
                        (v) => {
                          reject(v);
                        }
                      );
                    } else {
                      resolve(result);
                    }
                  } catch (error) {
                    reject(error);
                  }
                },
                onReject: () => {
                  let result = onReject(this.value);
                  try {
                    if (result instanceof HD) {
                      result.then(
                        (r) => {
                          resolve(r);
                        },
                        (v) => {
                          reject(v);
                        }
                      );
                    } else {
                      resolve(result);
                    }
                  } catch (error) {
                    reject(error);
                  }
                },
              });
            }
          });

          return thenResult;
        }

        catch() {
          return this.then(undefined, onReject);
        }
      }

      // 做用slice函数做分页分割时，或者数组分割时 前一个永远比后一个参数page少1  slice(index*size,(index+1)*size)
      // 前端分页 slice((page-1)*size,page*size)
    </script>
  </body>
</html>

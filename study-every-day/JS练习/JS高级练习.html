<!--
 * @Author: your name
 * @Date: 2021-03-04 19:54:14
 * @LastEditTime: 2021-08-13 10:37:22
 * @LastEditors: Please set LastEditors
 * @Description: In User Settings Edit
 * @FilePath: \web\JS练习\JS高级练习.html
-->
<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>

<div class="hd"></div>
<style>
  @keyframes identifier {
    0% {
      background-color: rgba(0, 0, 0, .5)
    }

    ;

    100% {
      background-color: saddlebrown
    }

    ;
  }

  @media screen and(max-width: 800px) and(min-width: 400px) {
    html {
      font-size: 12px;
    }
  }

  .container {
    object-fit: contain;
    animation: identifier 5s linear 1 alternate none;
    font-style: oblique;
    word-wrap: normal;
    display: flex;
    justify-content: space-between;
    align-content: space-between;
    flex-flow: column nowrap;
    background: url() no-repeat 0 0 fixed;
    position: fixed;
    z-index: -1;
    position: absolute;
    z-index: -1;
    width: calc(100%);
    height: 100vh;
    clear: both;
    background-size: cover;
    letter-spacing: 1px;
    white-space: nowrap;
    text-overflow: ellipsis;
    overflow: hidden;
    background: -o-linear-gradient(to right top red blue);
    max-width: 100%;
    height: auto;
    box-sizing: border-box;
    border-radius: 50%;
    box-shadow: 0 1px 5 rgba(0, 0, 0, .5);
    text-align: center;
    margin: auto;
    visibility: hidden;
    vertical-align: middle;
    font-weight: bold;
    font-family: '宋体';
    list-style: none;
    text-indent: 1px;
    text-decoration: none;
    border: 1px solid red;
    position: sticky;
    position: absolute;
    top: 0;
    left: 0;
    filter: blur(1px);
    background-color: rgba(0, 0, 0, .5);
    opacity: .1;
    transition: all 1s;
    transform: translate(5px, 5px);
    object-fit: contain;
  }

  .text {
    background-color: #ccc;
    width: 100%;
    height: 40px;
    line-height: 40px;
    text-align: center;
    /* border-radius: 10px; */
    color: rgb(102, 74, 74);
    /* position: fixed; */
    position: sticky;
    ;
    top: 0px;
    left: 0;
  }

  .h3000 {
    margin-top: 40px;
    height: 3000px;
    width: calc(100%-100px);
    background-color: red;
  }

  .container-box {
    display: inline-flex;
    margin-top: 100px
  }

  .container-box div {
    background: red;
    width: 50px;
  }

  .main {
    background-color: black;
    display: inline-block
  }
</style>
<!-- <div class="container">
  </div> -->


<div class="main">主1体</div>

<div class="text">我是嫩叠</div>
</br>
</br>
</br>
</br>
</br>
</br>
</br>
</br>
</br>
</br>
</br>
</br>
</br>
</br>
</br>
</br>
</br>
</br>
</br>
</br>
</br>
</br>
</br>
</br>
</br>
</br>
</br>
</br>
</br>
</br>
</br>
</br>
</br>
</br>
<div class="container-box">
  <div>1</div>
  <div>2</div>
  <div>3</div>
</div>
<div class="main">主体</div>

<script>
  // let name = '浏览器'
  // let age = 18
  // let obj = {
  //   a: [1, 2,],
  //   b: 'bb',
  // }
  // let arr1 = [1, 2, 3, 5, 6]
  // let arr2 = []
  // for (let i = 0; i < arr1.length; i++) {
  //   arr2.push(arr1[i])
  // }
  // let str = 'abc123 8 34'
  // let str1 = de = 'fegsgsfvt'
  // console.log(str.match(/\d+/g));//返回一个匹配到的数组
  // //console.log(str.search(/abc/));
  // var str4 = "abc DEF!"
  // console.log(str4.search(/DEF/))//4
  // console.log(str.includes('0'));//返回布尔值
  // console.log(str.indexOf('5'));//返回下标值，如果没有就返回-1
  // console.log(str1.charAt(1));//根据下表值返回对应的值
  // console.log(str.concat(str1));//连接字符串
  // console.log(str.replace('a', 'A'));//第一个值是原要替换的字符串（也可以是正则表达式），第二个值是替换成的值
  // let str2 = "bc def ghk"
  // console.log(str2.slice(2, 6))//slice()是提取字符串返回新的字符串不会改变原来的字符串（开始下标，结束下标-1）

  // var str5 = "abcdef,ghi jkl"
  // console.log(str5.split(''));
  // console.log(str5.toLocaleUpperCase());
  // for (let i of str2) {
  //   console.log(i);
  // }
  // let name1 = "Bob", time = "today";
  // console.log(`Hello ${name1}, how are you ${time}?`);
  // let a = +new Date()//获取日期对象
  // console.log(a);
  // class star {
  //   constructor(name, age, weight) {
  //     this.name = name,
  //       this.age = age,
  //       this.weight = weight
  //   }
  //   sing(a, b) {
  //     return a + b
  //   }
  // }
  // class star2 extends star {
  //   constructor(find, info) {

  //   }
  // }


  // //面向对象编程es6
  // class Animal {
  //   //每一个类都有构造器，如果没有写会被自动添加
  //   constructor(name, age) {
  //     this.name = name
  //     this.age = age
  //   }
  //   eat() { // 实例方法   原型方法
  //     // 实际上类的所有方法都定义在类的prototype属性上面
  //     // 在类的实例上面调用方法，其实就是调用原型上的方法。  
  //     console.log('吃吃吃')
  //   }
  //   //静态方法
  //   static sleep() {// 静态方法只能由类本身进行调用，实例不能调用
  //     console.log('睡睡睡')
  //   }
  // }
  // class Dog extends Animal {
  //   constructor(name, age, gender) {
  //     super(name, age)
  //     this.gender = gender
  //   }
  //   food() {
  //     super.eat()
  //   }
  //   static night() {
  //     super.sleep()
  //   }
  // }
  // let dog = new Dog('zs', 12, 'male')
  // console.log(dog)
  // console.log(dog instanceof Dog)   //true
  // console.log(Dog instanceof Animal)  //true
  // console.log(dog instanceof Animal)  //true
  // dog.food()
  // // dog.night()    //不能调用静态方法,只能类本身调用
  // Dog.night()

  // class Fa {
  //   constructor(x, y) {
  //     this.x = x;
  //     this.y = y;
  //   }
  //   sum() {
  //     var su = this.x + this.y;
  //     console.log(su);
  //   }
  // }
  // class Son extends Fa {
  //   constructor(x, y) {
  //     super(x, y);// 调用了父类的构造函数constructor
  //   }
  // }
  // var son = new Son(1, 2);
  // son.sum();
  // console.log(son);
  
  // localStorage.setItem('key', str)
  // localStorage.getItem('key')
  // localStorage.removeItem('key')
  // localStorage.clear()

  // sessionStorage.clear()

  // sessionStorage.setItem()

  //     let str = 'gasd';
  //     const arr = [1]
  //       console.log(arr.__proto__==Array.prototype);
  //       console.log(Array.isArray(arr));
  //       console.log(str.__proto__ == String.prototype);
  //       console.log(new String('2') instanceof Object);
  //       console.log(new Number(1) instanceof Number);

  //       //判断页面大小
  // const onResize=()=>{
  //   let pwidth = 1920;
  //   let prem = 100;
  //   let html = document.getElementsByTagName("html")[0];
  //   let oWidth = document.body.clientWidth || document.documentElement.clientWidth;
  //   if (oWidth > 1300) {
  //     oWidth = 1920
  //     html.style.fontSize = oWidth / pwidth * prem + "px";
  //   } else if(oWidth>800) {
  //     oWidth = oWidth + 400
  //     html.style.fontSize = oWidth / pwidth * prem + "px";
  //   } else if(oWidth<800){
  //     //手机适配
  //     let pwidth = 750;
  //     let prem = 100;
  //     let html = document.getElementsByTagName("html")[0];
  //     let oWidth = document.body.clientWidth || document.documentElement.clientWidth;
  //     html.style.fontSize = oWidth/pwidth*prem + "px";
  //   }


  //   class User {}
  //   let a = new User();

  //   let b= Object.create(User.prototype)



  //   console.log(a,b);




  // let _data1 = {
  //   "一级 1": {
  //     "children": [
  //       {
  //         "二级 1-1": {
  //           "children": ["三级 1-1-1", "三级 1-1-2"]
  //         }
  //       },

  //       "二级 1-2",

  //       {
  //         "二级 1-3": {
  //           "children": [
  //             {
  //               "三级 1-3-1": {
  //                 "children": ["四级 1-3-1-1", "四级 1-3-1-2"]
  //               }
  //             }
  //           ]
  //         }
  //       }
  //     ]
  //   }
  // }

  // for (let [k, v] of Object.entries(_data1)) {
  //   for (let [k1, v1] of Object.entries(v)) {
  //     for (let item of v1) {
  //       for (let [k2, v2] of Object.entries(item)) {
  //         for (let [k3, v3] of Object.entries(v2)) {
  //           for (let item1 of v3) {
  //             for (let [k4, v4] of Object.entries(item1)) {
  //               for (let [k5, v5] of Object.entries(v4)) {
  //                 for (let item2 of v5) {
  //                   console.log(item2);
  //                 }
  //               }
  //             }
  //           }
  //         }
  //       }
  //     }
  //   }
  // }


  // 休眠函数
  async function sleep() {
    return new Promise(resolve => {
      setTimeout(resolve, 1000)
    })
  }
  // (async function (id){
  //   let i = 10

  // //  while(i>0){
  // //     await sleep()
  // //     console.log(i);
  // //     i--
  // //  }


  // let {name:res} = {name:'jj',age:20}
  // console.log(res);

  // let obj = [
  //   { id: 0, name: '全部' },
  //   { id: 1, name: 'a' },
  //   { id: 2, name: 'b' },
  //   { id: 3, name: 'c' },
  //   { id: 4, name: 'd' },
  //   { id: 5, name: 'e' },
  // ]
  // let objId = [];
  // objId.indexOf(item)
  // function currentObj(item) {
  //   if(objId.length<=2){
  //     const flat = objId.some((id) => id === item.id);
  //     objId = flat ? objId.filter(item => item !== item.id) : [...objId, item.id];
  //   }
  // }

  // const filterNonUnique = arr => arr.filter(i => arr.indexOf(i) === arr.lastIndexOf(i));
  // const filterNonUnique = arr => arr.filter(i,index=> arr.indexOf(i) === idnex);

  // ??运算符 当前一个为null 或者undefined 就返回后一个否则返回前一个值
  // console.log(true??1);
  // console.log(0||1);


  /**
   * 过滤数组中的引用类型
   */
  function unique(arr) {
    let newArr = []
    let obj = {}
    arr.forEach(item => {
      if (typeof item !== 'object') {
        if (newArr.indexOf(item) === -1) newArr.push(item)
      } else {
        let str = JSON.stringify(item)
        if (!obj[str]) {
          newArr.push(item)
          obj[str] = 1
        }
      }
    })
    return newArr
  }

  //深拷贝
  function copyDeep(obj) {
    let res = obj instanceof Array ? [] : {};
    for (let [v, k] of Object.entries(obj)) res[v] = typeof k == 'object' ? copy(k) : k;
    return res;
  }
  // console.log(str.split(''));
  // //求数组中出现最多的次数
  //   let a =str.split('').reduce(function (pre, cur) {
  //   pre += String(pre) === String(cur) ? 1 : 0
  //   console.log(pre, cur)
  //   return pre
  // }, 0)
  // console.log(a);
  // let str = 'ffhdhrdegfnertfb';

  // let count = 0;
  // let tempObj = {};
  function fn(str) {
    for (let i of str) {
      if (!tempObj[i]) {
        tempObj[i] = 1
      } else {
        tempObj[i]++
      }
    }
    let val;
    let max = 0
    for (let i in tempObj) {
      if (max < tempObj[i]) {
        max = tempObj[i]
        val = i
      }
    }
    return {
      val, max
    }
  }

  // let llq=  [45, 2, 1, 0, 48, 9594, 285];
  //   // console.log(Math.max.apply(Math, [45, 2, 1, 0, 48, 9594, 285]));
  //   // console.log(Math.max(...gs))
  //     let max = 0;

  //   for(let i = 0; i < llq.length; i++){
  //     if(llq[i]<max){
  //       max=llq[i]
  //     }
  //   }
  // console.log(2??1);
  // let llq = {
  //   friends:{
  //     name:'aa',
  //     age:20,
  //   }
  // }
  // let gd = false??1
  // console.log(gd);
  // const a = llq.friends?.name
  // const b = llq?.friends
  // const bc = llq.ge?.aaa
  // console.log(a);
  // console.log(b);
  // console.log(bc);

  // setTimeout(() => {
  //   console.log(1);
  // },1000)
  // new Promise(resolve=>{
  //   setTimeout(()=>{
  //     console.log(2);

  //     resolve()
  //   },1000)
  // }).then(()=>{
  //   console.log(3);
  // })

  // const llq = (num)=>num === 1 ? 1 :num + llq(num - 1);
  // let reslut = llq(100);
  // console.log(reslut);



  /**
   *  // 策略模式 可以代替简单的if else switch
   * 
   */
  // const a = (value) => {
  //   const obj = {
  //     1: '基础',
  //     2: '高级',
  //     3: 'VIP',
  //   }
  //   return obj[value]
  // }
  // console.log(a('1'));


  const deepFlatten = arr => [].concat(...arr.map(v => Array.isArray(v) ? deepFlatten(v) : v));
  // deepFlatten([1,[2],[[3],4],5]) -> [1,2,3,4,5]


  const flatten = arr => {
    let temp = [];
    for (let item of arr) Array.isArray(item) ? temp.push(...flatten(item)) : temp.push(item)
    return temp;
  }
  let a = flatten([[2], 1, [[[3], 4], 5], 6]);


  function test(array) {
    let newArray = [];
    for (let i = 0; i < array.length; i++) {
      if (array[i] instanceof Array) {//判断是不是数组
        newArray = newArray.concat(test(array[i]));
        // newArray.push(...test(array[i]));
      } else {
        newArray.push(array[i]);
      }
    }
    return newArray;
  }

  let b = test([[2], 1, [[[3], 4], 5], 6]);


  // let bb = test([[2], 1, [[[3], 4], 5], 6])
  // console.log(bb);
  //main 
  // let gsd = { gs: 2 }

  // Object.hasownProperty()
  // gs in gsd

  // Object.getOwnPropertyDescriptor()
  // Object.getOwnPropertyDescriptors()

  // Object.defineProperty(obj, 'name',{
  //   value: '',
  //   writable: true,
  //   enumerable: true,
  //   configurable: true,
  // })

  // Object.defineProperties(obj, {
  //   name: {
  //     value: '',
  //     writable: true,
  //     enumerable: true,
  //     configurable: true,
  //   },
  //   age: {
  //     value: '',
  //     writable: true,
  //     enumerable: true,
  //     configurable: true,
  //   },

  // })

  //  //封闭对象 
  //  Object.seal() 
  //  //冻结对象
  //  Object.freeze() 
  const DATA = Symbol('1')
  const user = {
    [DATA]: { name },
    age: 20,
    nums: [5, 256, 4, 8, 48, 7],
    set setAge(value) {
      if (value < 50) throw new Error('年龄不能小于50岁')
      this.age = `${this.age}岁`;
    },
    get total() {
      return this.nums.reduce((prv, cur) => prv + cur, 0)
    },
    set token(value) {
      localStorage.setItem('token', value)
    },
    get token() {
      if (!token) {
        alert('请登录')
        return;
      }
      return localStorage.getItem('token')
    }
  }

  // const hd = { name: 'llq' }
  // const proxy = new Proxy(hd, {
  //   get(obj, property) {
  //     return obj[property];
  //   },
  //   set(obj, property, value) {
  //     obj[property] = value
  //     return true;
  //   }
  // });
  // console.log(proxy.name);
  // proxy.name = 'gsdniogn'
  // console.log(proxy.name);
  // let tsr1 = 3.141195;
  // Number.parseFloat('a3.1jj411lift95')
  // console.log(Number.parseFloat('3.1h41g195'));
  // console.log(Number.parseInt('3hhhs.141shh1h95'));
  // // Number.parseInt(3.141195)

  // tsr1 = tsr1.toFixed(2)//返回String
  // console.log(typeof tsr1,tsr1);
  const wb = [11]
  const hh = ['11']
  const lj = {
    age: 20,
  }

  let arr = [11, 22, 33, 44, 50, 66, 77, 88, 90, 100, 110, 115]
  /**
   * @description: 
   * @param {*} arr
   * @return {*}
   */
  function splitArr(arr) {
    const pathArr = []
    const lineArr = []
    arr.reduce((curr, next, index) => {
      if (next - curr > 9) {
        lineArr.push(curr)
      } else {
        lineArr.push(curr)
        pathArr.push(lineArr);
        lineArr.length = 0;
      }
      if (index === arr.length - 1) lineArr.push(next)
      return next
    })
    if (lineArr.length) pathArr.push(lineArr);
  }
  splitArr(arr)

  const isSplitLine = () => {
    let pathArr = []
    let lineArr = []
    for (let i = 0; i < arr.length; i++) {
      if (lineArr.length === 0) {
        lineArr.push(arr[i])
      } else {
        if (arr[i] - arr[i - 1] > 9) {
          lineArr.push(arr[i])
        } else {
          pathArr.push(lineArr);
          lineArr = []
          i--
        }
      }
    }
    if (lineArr.length) pathArr.push(lineArr);
    return pathArr
  }


  // ++i 先加1 最后在计算

  // i++ 先计算 最后再加1

  // console.log(JSON.stringify(wb) === JSON.stringify(hh));
  // console.log(Object.entries(wb).toString() === Object.entries(hh).toString());
  // console.log(lj.valueOf());

  //==========DOM操作必需知道的知识==========

  //视口就是所看到的区域所以文档范围 >= 视口范围 没有滚动条的时候文档 == 视口
  //absolute,relative定位相对于文档body  而fixed定位相对于视口  stacky
  document.body//(body)
  document.documentElement//html
  window.innerWidth//返回视口的宽度(包括滚动条)
  document.body.clientWidth || document.documentElement.clientWidth//返回视口的宽度(不包括滚动条)

  // e.pageY (相对于文档的坐标)
  // e.clientY(相对于视口的坐标)
  // e.offsetY(相对于事件触发盒子的坐标)
  
  // element.offsetWidth 返回元素的width 包括边框
  // element.clientWidth 返回元素的width 不包括边框
  // element.scrollWidth  返回元素的width 包括边框 和超出内容的部分
  // element.screenWidth 返回屏幕的width

  // element.parentNode 返回带有定位的父级元素

  // element.offserLeft 返回距离带有定位的父级的距离 没有则返回到文档的距离
  // element.clientLeft 返回内部到外面的距离
  // element.scrollLeft 页面滚动的距离
  // element.socreenLeft 

  // function fun() {
  //   let num = 0;
  //   return function () {
  //     num++
  //     console.log(num);
  //   }
  // }
  // this 跟对象原型没关系 ,始终指向调用属性或方法的对象

  // prototype 构造函数的原型,服务于通过构造函数new出来的无数个实例对象,因为new出来的对象的原型__proto__对自动指向构造函数的prototype
  //__proto__ 对象的原型, 服务于对象自己本身以及他的子对象

  // super 当前对象的原型 this.__proto__ === super  true

  // function setup() {
  //   const student = {
  //     name: 'lll',
  //     age: 20
  //   }
  //   const hd = Object.create(student)
  //   return  hd 
  // }
  // let reslut = setup()
  // console.log(reslut);

  const request = {
    name: 'request',
    axios() {
      console.log('发送请求');
    }
  }
  const total = {
    __proto__: request,
    computed() {
      console.log(super.name + '计算总价');
      console.log(this.__proto__.name)
      // console.log(super)
    }
  }

  // console.log(total.computed());

  function Father(name, age) {
    this.name = name
    this.age = age
  }
  // Father.prototype.show = function () {
  //   console.log(this.name, this.age);
  // }
  // Father.prototype.say = function () {
  //   console.log('father唱歌');
  // }
  Father.prototype = {
    constructor: Father,
    show() {
      console.log('该对象的:' + this.name, this.age);
    },
    sing() {
      console.log('father唱歌');
    }
  }
  // Son.prototype={ ...Son.prototype,...request,...total, }

  //构造函数原型的的原型继承
  Son.prototype = Object.create(Father.prototype)
  Object.defineProperty(Son.prototype, 'constructor', {
    value: Son,
    writable: false,
  })
  Son.prototype = Object.assign(Son.prototype, request, total)

  function Son(name, age) {
    Father.call(this, name, age)
  }
  const son = new Son('llq', 20);
  // console.log(son.sing());

  // console.log(son);
  // console.log(son.show());
  let sym = Symbol('1')
  let sym2 = Symbol('2')
  const llq = {
    name: 'hfd',
    age: 18,
    [sym]: '这是Symbol',
    [sym2]: '这是Symbol2'
  }
  // console.log(Object.getOwnPropertySymbols(llq));
  Object.getOwnPropertySymbols() //获取所有Symbol的key
  const bbb = Object.getOwnPropertySymbols(llq).map(
    item => {
      return llq[item]
    }
  )
  let array = [...bbb, ...Object.values(llq)]

  // console.log(array);
  // console.log(Object.values(llq));
  // const aaa = [...Object.values(llq), llq[Object.getOwnPropertySymbols(llq)[0]]]
  // console.log(aaa);
  // 当对象属性值是变量时,用obj[变量名]获取属性值,当对象属性值是字符串时,可以用 obj.字符串名 或者obj[字符串名]
  
  // console.log(Object.prototype.constructor===llq.__proto__.constructor);
  // console.dir(llq);
  // const HOST = Symbol()
  // let obj = {
  //   [HOST]: 'www',
  //   user: {
  //     name: 'lql',
  //     age: 20
  //   },
  //   price: 100,
  // }
  // // obj.Symbol()='111'
  // console.log(obj);
  // const map = new Map([['a',2],[111,3]]);
  // map.set('abc', 1)
  // map.set(obj, 21)
  // map.get('abc') 
  // console.log(map.get('abc'));
  // console.log(map);
  // let set = new WeakSet([[{},1]])
  // console.log(new Set([{}]));

  //  console.dir(window.getComputedStyle());

  async function de() {
    return new Promise(resolve => {
      setTimeout(resolve)
    })
    // return 10
  }
  // de().then(i => {
  //   console.log(21);
  // })
  // console.log(de());
  // function callBack(callBack){
  //   callBack && callBack(1)
  // }
  //   callBack((a)=>{
  //     console.log(a);
  //   })

  // console.log( ?? 1  );

  // let p1 = new Promise((resolve, reject) => {
  //   resolve()
  //   // reject(1)
  // }).then(() => {
  //   // return new Promise((resolve, reject) => {
  //   //    resolve(2)
  //   // })
  //   return 'fg'
  // }
  // ).then(
  //   (msg) => {
  //     console.log('msg:'+msg);
  //   },
  //   (error) => {
  //     console.log('error:'+error);
  //   }
  // )

  // const ajax = new XMLHttpRequest()
  // new WeakSet('112')
  // new FileReader()
  // console.dir(p1);
  // const w = new Image();
  // const img = document.createElement('a')
  // console.dir(w);
  // console.dir(img);


  // 手写Promise对象
  // class Pmise {
  //   static PENDING = 'pending'
  //   static FULFILLED = 'fulfilled'
  //   static REJECT = 'reject'
  //   constructor(callback) {
  //     this.status = 'pending'
  //     this.value = null
  //     this.callbackFn = []
  //     try {
  //       callback(this.resolve.bind(this), this.reject.bind(this))
  //     } catch (error) {
  //       this.reject(error)
  //     }
  //   }

  //   resolve(params) {
  //     if (this.status === Pmis.PENDING) {
  //       this.status === FULFILLED
  //       this.value = params
  //     }
  //     if (this.callbackFn.length) {
  //       setTimeout(() => {
  //         this.callbackFn.map((fnObj) => {
  //           fnObj.resolveFn(params)
  //         })
  //       });
  //     }
  //   }

  //   reject(params) {
  //     if (this.status === Pmis.PENDING) {
  //       this.status === REJECT
  //       this.value = params
  //       if (this.callbackFn.length) {
  //         setTimeout(() => {
  //           this.callbackFn.map((fnObj) => {
  //             fnObj.rejectFn(params)
  //           })
  //         });
  //       }
  //     }
  //   }

  //   then(resolveFn, rejectFn) {
  //     if (typeof resolveFn !== 'function') {
  //       resolveFn = () => this.value
  //     }
  //     if (typeof rejectFn !== 'function') {
  //       rejectFn = () => this.value
  //     }
  //     return new Pmis((nextResolve, nextReject) => {
  //       if (this.status === PENDING) {
  //         this.callbackFn.push({
  //           resolveFn: params => {
  //             try {
  //               let reslut = resolveFn(params)
  //               if (reslut instanceof Pmis) {
  //                 reslut.then(nextResolve, nextReject)
  //                 nextResolve(reslut)
  //               } else {
  //                 nextResolve(reslut)
  //               }
  //             } catch (error) {
  //               nextReject(error)
  //             }
  //           },
  //           rejectFn: params => {
  //             try {
  //               let reslut = rejectFn(params)
  //               if (reslut instanceof Pmis) {
  //                 reslut.then(nextResolve, nextReject)
  //                 nextResolve(reslut)
  //               } else {
  //                 nextResolve(reslut)
  //               }
  //             } catch (error) {
  //               nextReject(error)
  //             }
  //           }
  //         })
  //       }
  //       if (this.status === FULFILLED) {
  //         setTimeout(() => {
  //           try {
  //             let reslut = resolveFn(this.value)
  //             if (reslut instanceof Pmis) {
  //               reslut.then(nextResolve, nextReject)
  //               nextResolve(reslut)
  //             } else {
  //               nextResolve(reslut)
  //             }
  //           } catch (error) {
  //             nextReject(error)
  //           }
  //         })
  //       }
  //       if (this.status === REJECT) {
  //         setTimeout(() => {
  //           this.pase(rejectFn(this.value), nextResolve, nextReject)
  //            try {
  //              let reslut = rejectFn(this.value)
  //              if (reslut instanceof Pmis) {
  //                reslut.then(nextResolve, nextReject)
  //                nextResolve(reslut)
  //              } else {
  //                nextResolve(reslut)
  //              }
  //            } catch (error) {
  //              rejectFn(error)
  //            }
  //         })
  //       }
  //     })
  //   }
  // }



  let value = ["adsghasdghq131dadqe1", "qw1231fekuyjyujtyw34234wetete", "qweq12314twr12313131", "wr12313131qw2314tdas", "qwequiqweasdaduqweie"];
  let code = value.join(`\n`); // 按数组每一项转换为每一行数据
  // console.log(code);

  function gsg(arr, num) {
    let temp = []
    let index = 0
    while (index < arr.length) {
      temp.push(arr.slice(index, index += num))
    }
    // return temp.join(`\n`);
    return temp
  }

  // console.log(gsg(value, 2));
  // const isSplitLine = () => {
  //   let pathArr = []
  //   let lineArr = []
  //   for (let i = 0; i < arr.length; i++) {
  //     if (lineArr.length === 0) {
  //       lineArr.push(arr[i])
  //     } else {
  //       if (arr[i] - arr[i - 1] > 9) {
  //         lineArr.push(arr[i])
  //       } else {
  //         pathArr.push(lineArr);
  //         lineArr = []
  //         i--
  //       }
  //     }
  //   }
  //   if (lineArr.length) pathArr.push(lineArr);
  //   return pathArr
  // }

  //   let valA = 10n;
  //   let valB = BigInt(10);

  // console.log(2);
  // async function aaa() {
  //   return 1
  // }
  // setTimeout(() => {
  //   console.log(451);
  // })
  // async function q(params) {
  //   console.log(1);
  //   console.log(5);
  //   // let reslut = await aaa()
  //   console.log(4);

  //   // console.log(reslut);
  //   console.log(3);
  // }

  // console.log(28);
  // console.log(26);
  // q()

  // DOM节点类型 node.nodeType 1是元素标签element 2是元素标签上的属性Attr 3是标签的内容text  4是注释

  // class Admin {
  //   constructor(name) {
  //     this.name = name
  //   }
  // }

  // class User extends Admin {
  //   // age = 10;
  //   constructor(name, age) {
  //     super(name)
  //     this.age = age;
  //   }
  // }
  // let u = new User(new User('llq', 20));
  // console.log(new User('llq', 20));
  // console.log(User.prototype.constructor);
  function Admin(name) {
    this.name = name
  }

  User.prototype = Object.create(Admin.prototype);
  Object.defineProperty(User.prototype, 'constructor', {
    value: User,
    enumerable: false
  });
  function User(name, age) {
    Admin.call(this, name)
    this.age = age
  }
  let u = new User('llq', 20);
  // console.log(u);
  // console.log('HGDGD'.charAt(0));
  // console.log('HGDGD'.endsWith('D'));
  console.log('a'.charCodeAt(0));

  //字符串大小比较 会比较第一个字符串的阿斯科码
  // console.log('caa' > 'yahb');
  // console.log('1' > '10');

  const div = document.getElementById('hd')
  function handle() {
    let i = 0;
    (function run() {
      console.log(i);
      div.innerHTML = i
      div.style.width = i + '%'
      if (++i <= 100) setTimeout(run, 10)
    })()
  }
  // handle()

  async function load() {
    for (let i = 0; i <= 100; i++) {
      await new Promise(resolve => {
        setTimeout(() => {
          resolve()
        }, 100)
      })
      div.innerHTML = i
      div.style.width = i + '%'
    }
  }
        // load()


    // async function sleep() {
    //   return new Promise(resolve => {
    //     setTimeout(resolve, 100)
    //   })
    // }
    // async function load() {
    //   for (let i = 0; i <= 100; i++) {
    //     div.innerHTML = i
    //     div.style.width = i + '%'
    //     await sleep()
    //   }
    // }
    // load()
    // window.onload=function(){
    // 	onResize()
    // }
    // window.onresize=function(){
    //   onResize()
    // }

    // function onResize() {



    // window.onresize=function(){
    // 	const html= document.documentElement
    // 	let oWidth = document.body.clientWidth || document.documentElement.clientWidth;
    // 	let num=20
    // 	console.log(html.style.fontSize=oWidth/num +'px');
    // }



    // let str = 'abcdef'

    // console.log(str.charAt(2));
    // console.log(str[2]);

    // console.log([...str].reverse().join(''));反转字符串
    // let totel = +str
    // console.log(totel);
    // let num =456
    // console.log(num);
    // let res=num+''
    // console.log(res);
    
//</script>
</body>

</html>